# Snapshot report for `dist/codegen/generators/__tests__/typescript-client.connection.test.js`

The actual snapshot is saved in `typescript-client.connection.test.js.snap`.

Generated by [AVA](https://ava.li).

## typescript generator - connection

> Snapshot 1

    `// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.␊
    // Please don't change this file manually but run `prisma generate` to update it.␊
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/␊
    ␊
    import { DocumentNode } from "graphql";␊
    import {␊
      makePrismaClientClass,␊
      BaseClientOptions,␊
      Model␊
    } from "prisma-client-lib";␊
    import { typeDefs } from "./prisma-schema";␊
    ␊
    export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &␊
      U[keyof U];␊
    ␊
    export interface Exists {␊
      house: (where?: HouseWhereInput) => Promise<boolean>;␊
      user: (where?: UserWhereInput) => Promise<boolean>;␊
    }␊
    ␊
    export interface Node {}␊
    ␊
    export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;␊
    ␊
    export interface Fragmentable {␊
      $fragment<T>(fragment: string | DocumentNode): Promise<T>;␊
    }␊
    ␊
    export interface Prisma {␊
      $exists: Exists;␊
      $graphql: <T = any>(␊
        query: string,␊
        variables?: { [key: string]: any }␊
      ) => Promise<T>;␊
    ␊
      /**␊
       * Queries␊
       */␊
    ␊
      house: (where: HouseWhereUniqueInput) => HouseNullablePromise;␊
      houses: (args?: {␊
        where?: HouseWhereInput;␊
        orderBy?: HouseOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => FragmentableArray<House>;␊
      housesConnection: (args?: {␊
        where?: HouseWhereInput;␊
        orderBy?: HouseOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => HouseConnectionPromise;␊
      user: (where: UserWhereUniqueInput) => UserNullablePromise;␊
      users: (args?: {␊
        where?: UserWhereInput;␊
        orderBy?: UserOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => FragmentableArray<User>;␊
      usersConnection: (args?: {␊
        where?: UserWhereInput;␊
        orderBy?: UserOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => UserConnectionPromise;␊
      node: (args: { id: ID_Output }) => Node;␊
    ␊
      /**␊
       * Mutations␊
       */␊
    ␊
      createHouse: (data: HouseCreateInput) => HousePromise;␊
      updateHouse: (args: {␊
        data: HouseUpdateInput;␊
        where: HouseWhereUniqueInput;␊
      }) => HousePromise;␊
      updateManyHouses: (args: {␊
        data: HouseUpdateManyMutationInput;␊
        where?: HouseWhereInput;␊
      }) => BatchPayloadPromise;␊
      upsertHouse: (args: {␊
        where: HouseWhereUniqueInput;␊
        create: HouseCreateInput;␊
        update: HouseUpdateInput;␊
      }) => HousePromise;␊
      deleteHouse: (where: HouseWhereUniqueInput) => HousePromise;␊
      deleteManyHouses: (where?: HouseWhereInput) => BatchPayloadPromise;␊
      createUser: (data: UserCreateInput) => UserPromise;␊
      updateUser: (args: {␊
        data: UserUpdateInput;␊
        where: UserWhereUniqueInput;␊
      }) => UserPromise;␊
      upsertUser: (args: {␊
        where: UserWhereUniqueInput;␊
        create: UserCreateInput;␊
        update: UserUpdateInput;␊
      }) => UserPromise;␊
      deleteUser: (where: UserWhereUniqueInput) => UserPromise;␊
      deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;␊
    ␊
      /**␊
       * Subscriptions␊
       */␊
    ␊
      $subscribe: Subscription;␊
    }␊
    ␊
    export interface Subscription {␊
      house: (␊
        where?: HouseSubscriptionWhereInput␊
      ) => HouseSubscriptionPayloadSubscription;␊
      user: (␊
        where?: UserSubscriptionWhereInput␊
      ) => UserSubscriptionPayloadSubscription;␊
    }␊
    ␊
    export interface ClientConstructor<T> {␊
      new (options?: BaseClientOptions): T;␊
    }␊
    ␊
    /**␊
     * Types␊
     */␊
    ␊
    export type HouseOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";␊
    ␊
    export type UserOrderByInput = "id_ASC" | "id_DESC";␊
    ␊
    export type MutationType = "CREATED" | "UPDATED" | "DELETED";␊
    ␊
    export interface HouseCreateInput {␊
      name: String;␊
      user: UserCreateOneWithoutHouseInput;␊
    }␊
    ␊
    export type HouseWhereUniqueInput = AtLeastOne<{␊
      id: ID_Input;␊
    }>;␊
    ␊
    export interface UserUpdateOneRequiredWithoutHouseInput {␊
      connect?: UserWhereUniqueInput;␊
    }␊
    ␊
    export interface HouseWhereInput {␊
      id?: ID_Input;␊
      id_not?: ID_Input;␊
      id_in?: ID_Input[] | ID_Input;␊
      id_not_in?: ID_Input[] | ID_Input;␊
      id_lt?: ID_Input;␊
      id_lte?: ID_Input;␊
      id_gt?: ID_Input;␊
      id_gte?: ID_Input;␊
      id_contains?: ID_Input;␊
      id_not_contains?: ID_Input;␊
      id_starts_with?: ID_Input;␊
      id_not_starts_with?: ID_Input;␊
      id_ends_with?: ID_Input;␊
      id_not_ends_with?: ID_Input;␊
      name?: String;␊
      name_not?: String;␊
      name_in?: String[] | String;␊
      name_not_in?: String[] | String;␊
      name_lt?: String;␊
      name_lte?: String;␊
      name_gt?: String;␊
      name_gte?: String;␊
      name_contains?: String;␊
      name_not_contains?: String;␊
      name_starts_with?: String;␊
      name_not_starts_with?: String;␊
      name_ends_with?: String;␊
      name_not_ends_with?: String;␊
      user?: UserWhereInput;␊
      AND?: HouseWhereInput[] | HouseWhereInput;␊
      OR?: HouseWhereInput[] | HouseWhereInput;␊
      NOT?: HouseWhereInput[] | HouseWhereInput;␊
    }␊
    ␊
    export interface UserUpdateInput {␊
      house?: HouseUpdateOneRequiredWithoutUserInput;␊
    }␊
    ␊
    export interface HouseUpdateInput {␊
      name?: String;␊
      user?: UserUpdateOneRequiredWithoutHouseInput;␊
    }␊
    ␊
    export interface HouseCreateWithoutUserInput {␊
      name: String;␊
    }␊
    ␊
    export interface HouseUpdateManyMutationInput {␊
      name?: String;␊
    }␊
    ␊
    export interface HouseCreateOneWithoutUserInput {␊
      create?: HouseCreateWithoutUserInput;␊
      connect?: HouseWhereUniqueInput;␊
    }␊
    ␊
    export interface HouseSubscriptionWhereInput {␊
      mutation_in?: MutationType[] | MutationType;␊
      updatedFields_contains?: String;␊
      updatedFields_contains_every?: String[] | String;␊
      updatedFields_contains_some?: String[] | String;␊
      node?: HouseWhereInput;␊
      AND?: HouseSubscriptionWhereInput[] | HouseSubscriptionWhereInput;␊
      OR?: HouseSubscriptionWhereInput[] | HouseSubscriptionWhereInput;␊
      NOT?: HouseSubscriptionWhereInput[] | HouseSubscriptionWhereInput;␊
    }␊
    ␊
    export interface HouseUpdateWithoutUserDataInput {␊
      name?: String;␊
    }␊
    ␊
    export interface UserCreateOneWithoutHouseInput {␊
      connect?: UserWhereUniqueInput;␊
    }␊
    ␊
    export interface UserWhereInput {␊
      id?: ID_Input;␊
      id_not?: ID_Input;␊
      id_in?: ID_Input[] | ID_Input;␊
      id_not_in?: ID_Input[] | ID_Input;␊
      id_lt?: ID_Input;␊
      id_lte?: ID_Input;␊
      id_gt?: ID_Input;␊
      id_gte?: ID_Input;␊
      id_contains?: ID_Input;␊
      id_not_contains?: ID_Input;␊
      id_starts_with?: ID_Input;␊
      id_not_starts_with?: ID_Input;␊
      id_ends_with?: ID_Input;␊
      id_not_ends_with?: ID_Input;␊
      house?: HouseWhereInput;␊
      AND?: UserWhereInput[] | UserWhereInput;␊
      OR?: UserWhereInput[] | UserWhereInput;␊
      NOT?: UserWhereInput[] | UserWhereInput;␊
    }␊
    ␊
    export interface UserCreateInput {␊
      house: HouseCreateOneWithoutUserInput;␊
    }␊
    ␊
    export interface HouseUpdateOneRequiredWithoutUserInput {␊
      create?: HouseCreateWithoutUserInput;␊
      update?: HouseUpdateWithoutUserDataInput;␊
      upsert?: HouseUpsertWithoutUserInput;␊
      connect?: HouseWhereUniqueInput;␊
    }␊
    ␊
    export interface HouseUpsertWithoutUserInput {␊
      update: HouseUpdateWithoutUserDataInput;␊
      create: HouseCreateWithoutUserInput;␊
    }␊
    ␊
    export interface UserSubscriptionWhereInput {␊
      mutation_in?: MutationType[] | MutationType;␊
      updatedFields_contains?: String;␊
      updatedFields_contains_every?: String[] | String;␊
      updatedFields_contains_some?: String[] | String;␊
      node?: UserWhereInput;␊
      AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;␊
      OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;␊
      NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;␊
    }␊
    ␊
    export type UserWhereUniqueInput = AtLeastOne<{␊
      id: ID_Input;␊
    }>;␊
    ␊
    export interface NodeNode {␊
      id: ID_Output;␊
    }␊
    ␊
    export interface UserPreviousValues {␊
      id: ID_Output;␊
    }␊
    ␊
    export interface UserPreviousValuesPromise␊
      extends Promise<UserPreviousValues>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
    }␊
    ␊
    export interface UserPreviousValuesSubscription␊
      extends Promise<AsyncIterator<UserPreviousValues>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
    }␊
    ␊
    export interface HouseEdge {␊
      node: House;␊
      cursor: String;␊
    }␊
    ␊
    export interface HouseEdgePromise extends Promise<HouseEdge>, Fragmentable {␊
      node: <T = HousePromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    export interface HouseEdgeSubscription␊
      extends Promise<AsyncIterator<HouseEdge>>,␊
        Fragmentable {␊
      node: <T = HouseSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface User {␊
      id: ID_Output;␊
    }␊
    ␊
    export interface UserPromise extends Promise<User>, Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      house: <T = HousePromise>() => T;␊
    }␊
    ␊
    export interface UserSubscription␊
      extends Promise<AsyncIterator<User>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      house: <T = HouseSubscription>() => T;␊
    }␊
    ␊
    export interface UserNullablePromise␊
      extends Promise<User | null>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      house: <T = HousePromise>() => T;␊
    }␊
    ␊
    export interface AggregateHouse {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregateHousePromise␊
      extends Promise<AggregateHouse>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregateHouseSubscription␊
      extends Promise<AsyncIterator<AggregateHouse>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface HouseSubscriptionPayload {␊
      mutation: MutationType;␊
      node: House;␊
      updatedFields: String[];␊
      previousValues: HousePreviousValues;␊
    }␊
    ␊
    export interface HouseSubscriptionPayloadPromise␊
      extends Promise<HouseSubscriptionPayload>,␊
        Fragmentable {␊
      mutation: () => Promise<MutationType>;␊
      node: <T = HousePromise>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T = HousePreviousValuesPromise>() => T;␊
    }␊
    ␊
    export interface HouseSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<HouseSubscriptionPayload>>,␊
        Fragmentable {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T = HouseSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T = HousePreviousValuesSubscription>() => T;␊
    }␊
    ␊
    export interface BatchPayload {␊
      count: Long;␊
    }␊
    ␊
    export interface BatchPayloadPromise␊
      extends Promise<BatchPayload>,␊
        Fragmentable {␊
      count: () => Promise<Long>;␊
    }␊
    ␊
    export interface BatchPayloadSubscription␊
      extends Promise<AsyncIterator<BatchPayload>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Long>>;␊
    }␊
    ␊
    export interface House {␊
      id: ID_Output;␊
      name: String;␊
    }␊
    ␊
    export interface HousePromise extends Promise<House>, Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      name: () => Promise<String>;␊
      user: <T = UserPromise>() => T;␊
    }␊
    ␊
    export interface HouseSubscription␊
      extends Promise<AsyncIterator<House>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
      user: <T = UserSubscription>() => T;␊
    }␊
    ␊
    export interface HouseNullablePromise␊
      extends Promise<House | null>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      name: () => Promise<String>;␊
      user: <T = UserPromise>() => T;␊
    }␊
    ␊
    export interface PageInfo {␊
      hasNextPage: Boolean;␊
      hasPreviousPage: Boolean;␊
      startCursor?: String;␊
      endCursor?: String;␊
    }␊
    ␊
    export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {␊
      hasNextPage: () => Promise<Boolean>;␊
      hasPreviousPage: () => Promise<Boolean>;␊
      startCursor: () => Promise<String>;␊
      endCursor: () => Promise<String>;␊
    }␊
    ␊
    export interface PageInfoSubscription␊
      extends Promise<AsyncIterator<PageInfo>>,␊
        Fragmentable {␊
      hasNextPage: () => Promise<AsyncIterator<Boolean>>;␊
      hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;␊
      startCursor: () => Promise<AsyncIterator<String>>;␊
      endCursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface HousePreviousValues {␊
      id: ID_Output;␊
      name: String;␊
    }␊
    ␊
    export interface HousePreviousValuesPromise␊
      extends Promise<HousePreviousValues>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      name: () => Promise<String>;␊
    }␊
    ␊
    export interface HousePreviousValuesSubscription␊
      extends Promise<AsyncIterator<HousePreviousValues>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface HouseConnection {␊
      pageInfo: PageInfo;␊
      edges: HouseEdge[];␊
    }␊
    ␊
    export interface HouseConnectionPromise␊
      extends Promise<HouseConnection>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoPromise>() => T;␊
      edges: <T = FragmentableArray<HouseEdge>>() => T;␊
      aggregate: <T = AggregateHousePromise>() => T;␊
    }␊
    ␊
    export interface HouseConnectionSubscription␊
      extends Promise<AsyncIterator<HouseConnection>>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoSubscription>() => T;␊
      edges: <T = Promise<AsyncIterator<HouseEdgeSubscription>>>() => T;␊
      aggregate: <T = AggregateHouseSubscription>() => T;␊
    }␊
    ␊
    export interface AggregateUser {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregateUserPromise␊
      extends Promise<AggregateUser>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregateUserSubscription␊
      extends Promise<AsyncIterator<AggregateUser>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface UserSubscriptionPayload {␊
      mutation: MutationType;␊
      node: User;␊
      updatedFields: String[];␊
      previousValues: UserPreviousValues;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadPromise␊
      extends Promise<UserSubscriptionPayload>,␊
        Fragmentable {␊
      mutation: () => Promise<MutationType>;␊
      node: <T = UserPromise>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T = UserPreviousValuesPromise>() => T;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<UserSubscriptionPayload>>,␊
        Fragmentable {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T = UserSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T = UserPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    export interface UserConnection {␊
      pageInfo: PageInfo;␊
      edges: UserEdge[];␊
    }␊
    ␊
    export interface UserConnectionPromise␊
      extends Promise<UserConnection>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoPromise>() => T;␊
      edges: <T = FragmentableArray<UserEdge>>() => T;␊
      aggregate: <T = AggregateUserPromise>() => T;␊
    }␊
    ␊
    export interface UserConnectionSubscription␊
      extends Promise<AsyncIterator<UserConnection>>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoSubscription>() => T;␊
      edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;␊
      aggregate: <T = AggregateUserSubscription>() => T;␊
    }␊
    ␊
    export interface UserEdge {␊
      node: User;␊
      cursor: String;␊
    }␊
    ␊
    export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {␊
      node: <T = UserPromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    export interface UserEdgeSubscription␊
      extends Promise<AsyncIterator<UserEdge>>,␊
        Fragmentable {␊
      node: <T = UserSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    /*␊
    The `Boolean` scalar type represents `true` or `false`.␊
    */␊
    export type Boolean = boolean;␊
    ␊
    /*␊
    The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.␊
    */␊
    export type ID_Input = string | number;␊
    export type ID_Output = string;␊
    ␊
    /*␊
    The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.␊
    */␊
    export type String = string;␊
    ␊
    /*␊
    The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. ␊
    */␊
    export type Int = number;␊
    ␊
    export type Long = string;␊
    ␊
    /**␊
     * Model Metadata␊
     */␊
    ␊
    export const models: Model[] = [␊
      {␊
        name: "User",␊
        embedded: false␊
      },␊
      {␊
        name: "House",␊
        embedded: false␊
      }␊
    ];␊
    ␊
    /**␊
     * Type Defs␊
     */␊
    ␊
    export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({␊
      typeDefs,␊
      models␊
    });␊
    export const prisma = new Prisma();␊
    `
