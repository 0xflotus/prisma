// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Introspects airbnb/mysql correctly: airbnb - legacy datamodel 1`] = `
"type Amenities {
  airConditioning: Boolean! @default(value: false)
  babyBath: Boolean! @default(value: false)
  babyMonitor: Boolean! @default(value: false)
  babysitterRecommendations: Boolean! @default(value: false)
  bathtub: Boolean! @default(value: false)
  breakfast: Boolean! @default(value: false)
  buzzerWirelessIntercom: Boolean! @default(value: false)
  cableTv: Boolean! @default(value: false)
  changingTable: Boolean! @default(value: false)
  childrensBooksAndToys: Boolean! @default(value: false)
  childrensDinnerware: Boolean! @default(value: false)
  createdAt: DateTime!
  crib: Boolean! @default(value: false)
  doorman: Boolean! @default(value: false)
  dryer: Boolean! @default(value: false)
  elevator: Boolean! @default(value: false)
  essentials: Boolean! @default(value: false)
  familyKidFriendly: Boolean! @default(value: false)
  freeParkingOnPremises: Boolean! @default(value: false)
  freeParkingOnStreet: Boolean! @default(value: false)
  gym: Boolean! @default(value: false)
  hairDryer: Boolean! @default(value: false)
  hangers: Boolean! @default(value: false)
  heating: Boolean! @default(value: false)
  hotTub: Boolean! @default(value: false)
  id: ID! @unique
  indoorFireplace: Boolean! @default(value: false)
  internet: Boolean! @default(value: false)
  iron: Boolean! @default(value: false)
  kitchen: Boolean! @default(value: false)
  laptopFriendlyWorkspace: Boolean! @default(value: false)
  paidParkingOffPremises: Boolean! @default(value: false)
  petsAllowed: Boolean! @default(value: false)
  place: Place!
  pool: Boolean! @default(value: false)
  privateEntrance: Boolean! @default(value: false)
  shampoo: Boolean! @default(value: false)
  smokingAllowed: Boolean! @default(value: false)
  suitableForEvents: Boolean! @default(value: false)
  tv: Boolean! @default(value: false)
  updatedAt: DateTime!
  washer: Boolean! @default(value: false)
  wheelchairAccessible: Boolean! @default(value: false)
  wirelessInternet: Boolean! @default(value: false)
}

type Booking {
  bookee: User!
  createdAt: DateTime!
  endDate: DateTime!
  id: ID! @unique
  payment: Payment!
  place: Place!
  startDate: DateTime!
  updatedAt: DateTime!
}

type City {
  createdAt: DateTime!
  id: ID! @unique
  name: String!
  neighbourhoods: [Neighbourhood]
  updatedAt: DateTime!
}

type CreditCardInformation {
  cardNumber: String!
  country: String!
  createdAt: DateTime!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  firstName: String!
  id: ID! @unique
  lastName: String!
  paymentAccount: PaymentAccount
  postalCode: String!
  securityCode: String!
  updatedAt: DateTime!
}

type Experience {
  category: ExperienceCategory
  createdAt: DateTime!
  host: User!
  id: ID! @unique
  location: Location!
  popularity: Int!
  preview: Picture!
  pricePerPerson: Int!
  reviews: [Review]
  title: String!
  updatedAt: DateTime!
}

type ExperienceCategory {
  createdAt: DateTime!
  experience: Experience
  id: ID! @unique
  mainColor: String! @default(value: \\"#123456\\")
  name: String!
  updatedAt: DateTime!
}

type GuestRequirements {
  createdAt: DateTime!
  govIssuedId: Boolean! @default(value: false)
  guestTripInformation: Boolean! @default(value: false)
  id: ID! @unique
  place: Place!
  recommendationsFromOtherHosts: Boolean! @default(value: false)
  updatedAt: DateTime!
}

type HouseRules {
  additionalRules: String
  createdAt: DateTime!
  id: ID! @unique
  partiesAndEventsAllowed: Boolean
  petsAllowed: Boolean
  smokingAllowed: Boolean
  suitableForChildren: Boolean
  suitableForInfants: Boolean
  updatedAt: DateTime!
}

type Location {
  address: String
  createdAt: DateTime!
  directions: String
  experience: Experience
  id: ID! @unique
  lat: Float!
  lng: Float!
  neighbourHood: Neighbourhood
  place: Place
  restaurant: Restaurant
  updatedAt: DateTime!
  user: User
}

type Message {
  createdAt: DateTime!
  deliveredAt: DateTime!
  from: User! @relation(name: \\"SentMessages\\")
  id: ID! @unique
  readAt: DateTime!
  to: User! @relation(name: \\"ReceivedMessages\\")
  updatedAt: DateTime!
}

type Neighbourhood {
  city: City!
  createdAt: DateTime!
  featured: Boolean!
  homePreview: Picture
  id: ID! @unique
  locations: [Location]
  name: String!
  popularity: Int!
  slug: String!
  updatedAt: DateTime!
}

type Notification {
  createdAt: DateTime!
  id: ID! @unique
  link: String!
  readDate: DateTime!
  type: NOTIFICATION_TYPE
  updatedAt: DateTime!
  user: User!
}

type Payment {
  booking: Booking!
  createdAt: DateTime!
  id: ID! @unique
  paymentMethod: PaymentAccount!
  placePrice: Float!
  serviceFee: Float!
  totalPrice: Float!
  updatedAt: DateTime!
}

type PaymentAccount {
  createdAt: DateTime!
  creditcard: CreditCardInformation
  id: ID! @unique
  payments: [Payment]
  paypal: PaypalInformation
  type: PAYMENT_PROVIDER
  updatedAt: DateTime!
  user: User!
}

type PaypalInformation {
  createdAt: DateTime!
  email: String!
  id: ID! @unique
  paymentAccount: PaymentAccount!
  updatedAt: DateTime!
}

type Picture {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  url: String!
}

type Place {
  amenities: Amenities!
  bookings: [Booking]
  createdAt: DateTime!
  description: String!
  guestRequirements: GuestRequirements
  host: User!
  houseRules: HouseRules
  id: ID! @unique
  location: Location!
  maxGuests: Int!
  name: String
  numBaths: Int!
  numBedrooms: Int!
  numBeds: Int!
  pictures: [Picture]
  policies: Policies
  popularity: Int!
  pricing: Pricing!
  reviews: [Review]
  shortDescription: String!
  size: PLACE_SIZES
  slug: String!
  updatedAt: DateTime!
  views: Views!
}

type Policies {
  checkInEndTime: Float!
  checkInStartTime: Float!
  checkoutTime: Float!
  createdAt: DateTime!
  id: ID! @unique
  place: Place!
  updatedAt: DateTime!
}

type Pricing {
  averageMonthly: Int!
  averageWeekly: Int!
  basePrice: Int!
  cleaningFee: Int
  createdAt: DateTime!
  currency: CURRENCY
  extraGuests: Int
  id: ID! @unique
  monthlyDiscount: Int
  perNight: Int!
  place: Place!
  securityDeposit: Int
  smartPricing: Boolean! @default(value: false)
  updatedAt: DateTime!
  weekendPricing: Int
  weeklyDiscount: Int
}

type Restaurant {
  avgPricePerPerson: Int!
  createdAt: DateTime!
  id: ID! @unique
  isCurated: Boolean! @default(value: true)
  location: Location!
  pictures: [Picture]
  popularity: Int!
  slug: String!
  title: String!
  updatedAt: DateTime!
}

type Review {
  accuracy: Int!
  checkIn: Int!
  cleanliness: Int!
  communication: Int!
  createdAt: DateTime!
  experience: Experience
  id: ID! @unique
  location: Int!
  place: Place!
  stars: Int!
  text: String!
  updatedAt: DateTime!
  value: Int!
}

type User {
  bookings: [Booking]
  createdAt: DateTime!
  email: String! @unique
  firstName: String!
  hostingExperiences: [Experience]
  id: ID! @unique
  isSuperHost: Boolean! @default(value: false)
  lastName: String!
  location: Location
  notifications: [Notification]
  ownedPlaces: [Place]
  password: String!
  paymentAccount: [PaymentAccount]
  phone: String!
  profilePicture: Picture
  receivedMessages: [Message] @relation(name: \\"ReceivedMessages\\")
  responseRate: Float
  responseTime: Int
  sentMessages: [Message] @relation(name: \\"SentMessages\\")
  updatedAt: DateTime!
}

type Views {
  createdAt: DateTime!
  id: ID! @unique
  lastWeek: Int!
  place: Place!
  updatedAt: DateTime!
}

enum CURRENCY {
  CAD
  CHF
  EUR
  JPY
  USD
  ZAR
}

enum NOTIFICATION_TYPE {
  OFFER
  INSTANT_BOOK
  RESPONSIVENESS
  NEW_AMENITIES
  HOUSE_RULES
}

enum PAYMENT_PROVIDER {
  PAYPAL
  CREDIT_CARD
}

enum PLACE_SIZES {
  ENTIRE_HOUSE
  ENTIRE_APARTMENT
  ENTIRE_EARTH_HOUSE
  ENTIRE_CABIN
  ENTIRE_VILLA
  ENTIRE_PLACE
  ENTIRE_BOAT
  PRIVATE_ROOM
}"
`;

exports[`Introspects airbnb/mysql correctly: airbnb - v1.1 datamodel 1`] = `
"type Amenities {
  airConditioning: Boolean! @default(value: false)
  babyBath: Boolean! @default(value: false)
  babyMonitor: Boolean! @default(value: false)
  babysitterRecommendations: Boolean! @default(value: false)
  bathtub: Boolean! @default(value: false)
  breakfast: Boolean! @default(value: false)
  buzzerWirelessIntercom: Boolean! @default(value: false)
  cableTv: Boolean! @default(value: false)
  changingTable: Boolean! @default(value: false)
  childrensBooksAndToys: Boolean! @default(value: false)
  childrensDinnerware: Boolean! @default(value: false)
  createdAt: DateTime! @createdAt
  crib: Boolean! @default(value: false)
  doorman: Boolean! @default(value: false)
  dryer: Boolean! @default(value: false)
  elevator: Boolean! @default(value: false)
  essentials: Boolean! @default(value: false)
  familyKidFriendly: Boolean! @default(value: false)
  freeParkingOnPremises: Boolean! @default(value: false)
  freeParkingOnStreet: Boolean! @default(value: false)
  gym: Boolean! @default(value: false)
  hairDryer: Boolean! @default(value: false)
  hangers: Boolean! @default(value: false)
  heating: Boolean! @default(value: false)
  hotTub: Boolean! @default(value: false)
  id: ID! @id
  indoorFireplace: Boolean! @default(value: false)
  internet: Boolean! @default(value: false)
  iron: Boolean! @default(value: false)
  kitchen: Boolean! @default(value: false)
  laptopFriendlyWorkspace: Boolean! @default(value: false)
  paidParkingOffPremises: Boolean! @default(value: false)
  petsAllowed: Boolean! @default(value: false)
  place: Place!
  pool: Boolean! @default(value: false)
  privateEntrance: Boolean! @default(value: false)
  shampoo: Boolean! @default(value: false)
  smokingAllowed: Boolean! @default(value: false)
  suitableForEvents: Boolean! @default(value: false)
  tv: Boolean! @default(value: false)
  updatedAt: DateTime! @updatedAt
  washer: Boolean! @default(value: false)
  wheelchairAccessible: Boolean! @default(value: false)
  wirelessInternet: Boolean! @default(value: false)
}

type Booking {
  bookee: User! @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  endDate: DateTime!
  id: ID! @id
  payment: Payment! @relation(link: TABLE)
  place: Place! @relation(link: TABLE)
  startDate: DateTime!
  updatedAt: DateTime! @updatedAt
}

type City {
  createdAt: DateTime! @createdAt
  id: ID! @id
  name: String!
  neighbourhoods: [Neighbourhood]
  updatedAt: DateTime! @updatedAt
}

type CreditCardInformation {
  cardNumber: String!
  country: String!
  createdAt: DateTime! @createdAt
  expiresOnMonth: Int!
  expiresOnYear: Int!
  firstName: String!
  id: ID! @id
  lastName: String!
  paymentAccount: PaymentAccount
  postalCode: String!
  securityCode: String!
  updatedAt: DateTime! @updatedAt
}

type Experience {
  category: ExperienceCategory @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  host: User! @relation(link: TABLE)
  id: ID! @id
  location: Location!
  popularity: Int!
  preview: Picture! @relation(link: TABLE)
  pricePerPerson: Int!
  reviews: [Review]
  title: String!
  updatedAt: DateTime! @updatedAt
}

type ExperienceCategory {
  createdAt: DateTime! @createdAt
  experience: Experience
  id: ID! @id
  mainColor: String! @default(value: \\"#123456\\")
  name: String!
  updatedAt: DateTime! @updatedAt
}

type GuestRequirements {
  createdAt: DateTime! @createdAt
  govIssuedId: Boolean! @default(value: false)
  guestTripInformation: Boolean! @default(value: false)
  id: ID! @id
  place: Place!
  recommendationsFromOtherHosts: Boolean! @default(value: false)
  updatedAt: DateTime! @updatedAt
}

type HouseRules {
  additionalRules: String
  createdAt: DateTime! @createdAt
  id: ID! @id
  partiesAndEventsAllowed: Boolean
  petsAllowed: Boolean
  smokingAllowed: Boolean
  suitableForChildren: Boolean
  suitableForInfants: Boolean
  updatedAt: DateTime! @updatedAt
}

type Location {
  address: String
  createdAt: DateTime! @createdAt
  directions: String
  experience: Experience @relation(link: TABLE)
  id: ID! @id
  lat: Float!
  lng: Float!
  neighbourHood: Neighbourhood @relation(link: TABLE)
  place: Place
  restaurant: Restaurant @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
  user: User
}

type Message {
  createdAt: DateTime! @createdAt
  deliveredAt: DateTime!
  from: User! @relation(link: TABLE, name: \\"SentMessages\\")
  id: ID! @id
  readAt: DateTime!
  to: User! @relation(link: TABLE, name: \\"ReceivedMessages\\")
  updatedAt: DateTime! @updatedAt
}

type Neighbourhood {
  city: City! @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  featured: Boolean!
  homePreview: Picture @relation(link: TABLE)
  id: ID! @id
  locations: [Location]
  name: String!
  popularity: Int!
  slug: String!
  updatedAt: DateTime! @updatedAt
}

type Notification {
  createdAt: DateTime! @createdAt
  id: ID! @id
  link: String!
  readDate: DateTime!
  type: NOTIFICATION_TYPE
  updatedAt: DateTime! @updatedAt
  user: User! @relation(link: TABLE)
}

type Payment {
  booking: Booking!
  createdAt: DateTime! @createdAt
  id: ID! @id
  paymentMethod: PaymentAccount! @relation(link: TABLE)
  placePrice: Float!
  serviceFee: Float!
  totalPrice: Float!
  updatedAt: DateTime! @updatedAt
}

type PaymentAccount {
  createdAt: DateTime! @createdAt
  creditcard: CreditCardInformation @relation(link: TABLE)
  id: ID! @id
  payments: [Payment]
  paypal: PaypalInformation @relation(link: TABLE)
  type: PAYMENT_PROVIDER
  updatedAt: DateTime! @updatedAt
  user: User! @relation(link: TABLE)
}

type PaypalInformation {
  createdAt: DateTime! @createdAt
  email: String!
  id: ID! @id
  paymentAccount: PaymentAccount!
  updatedAt: DateTime! @updatedAt
}

type Picture {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  url: String!
}

type Place {
  amenities: Amenities! @relation(link: TABLE)
  bookings: [Booking]
  createdAt: DateTime! @createdAt
  description: String!
  guestRequirements: GuestRequirements @relation(link: TABLE)
  host: User! @relation(link: TABLE)
  houseRules: HouseRules @relation(link: TABLE)
  id: ID! @id
  location: Location! @relation(link: TABLE)
  maxGuests: Int!
  name: String
  numBaths: Int!
  numBedrooms: Int!
  numBeds: Int!
  pictures: [Picture]
  policies: Policies @relation(link: TABLE)
  popularity: Int!
  pricing: Pricing! @relation(link: TABLE)
  reviews: [Review]
  shortDescription: String!
  size: PLACE_SIZES
  slug: String!
  updatedAt: DateTime! @updatedAt
  views: Views! @relation(link: TABLE)
}

type Policies {
  checkInEndTime: Float!
  checkInStartTime: Float!
  checkoutTime: Float!
  createdAt: DateTime! @createdAt
  id: ID! @id
  place: Place!
  updatedAt: DateTime! @updatedAt
}

type Pricing {
  averageMonthly: Int!
  averageWeekly: Int!
  basePrice: Int!
  cleaningFee: Int
  createdAt: DateTime! @createdAt
  currency: CURRENCY
  extraGuests: Int
  id: ID! @id
  monthlyDiscount: Int
  perNight: Int!
  place: Place!
  securityDeposit: Int
  smartPricing: Boolean! @default(value: false)
  updatedAt: DateTime! @updatedAt
  weekendPricing: Int
  weeklyDiscount: Int
}

type Restaurant {
  avgPricePerPerson: Int!
  createdAt: DateTime! @createdAt
  id: ID! @id
  isCurated: Boolean! @default(value: true)
  location: Location!
  pictures: [Picture]
  popularity: Int!
  slug: String!
  title: String!
  updatedAt: DateTime! @updatedAt
}

type Review {
  accuracy: Int!
  checkIn: Int!
  cleanliness: Int!
  communication: Int!
  createdAt: DateTime! @createdAt
  experience: Experience @relation(link: TABLE)
  id: ID! @id
  location: Int!
  place: Place! @relation(link: TABLE)
  stars: Int!
  text: String!
  updatedAt: DateTime! @updatedAt
  value: Int!
}

type User {
  bookings: [Booking]
  createdAt: DateTime! @createdAt
  email: String! @unique
  firstName: String!
  hostingExperiences: [Experience]
  id: ID! @id
  isSuperHost: Boolean! @default(value: false)
  lastName: String!
  location: Location @relation(link: TABLE)
  notifications: [Notification]
  ownedPlaces: [Place]
  password: String!
  paymentAccount: [PaymentAccount]
  phone: String!
  profilePicture: Picture @relation(link: TABLE)
  receivedMessages: [Message] @relation(name: \\"ReceivedMessages\\")
  responseRate: Float
  responseTime: Int
  sentMessages: [Message] @relation(name: \\"SentMessages\\")
  updatedAt: DateTime! @updatedAt
}

type Views {
  createdAt: DateTime! @createdAt
  id: ID! @id
  lastWeek: Int!
  place: Place!
  updatedAt: DateTime! @updatedAt
}

enum CURRENCY {
  CAD
  CHF
  EUR
  JPY
  USD
  ZAR
}

enum NOTIFICATION_TYPE {
  OFFER
  INSTANT_BOOK
  RESPONSIVENESS
  NEW_AMENITIES
  HOUSE_RULES
}

enum PAYMENT_PROVIDER {
  PAYPAL
  CREDIT_CARD
}

enum PLACE_SIZES {
  ENTIRE_HOUSE
  ENTIRE_APARTMENT
  ENTIRE_EARTH_HOUSE
  ENTIRE_CABIN
  ENTIRE_VILLA
  ENTIRE_PLACE
  ENTIRE_BOAT
  PRIVATE_ROOM
}"
`;

exports[`Introspects defaultValue/mysql correctly: defaultValue - legacy datamodel 1`] = `
"type A {
  a: Int @default(value: 10) @unique
  b: Int! @default(value: 10)
  c: String! @unique
  createdAt: DateTime!
  d: String @default(value: \\"Hello\\")
  id: ID! @unique
  updatedAt: DateTime!
}

type AWithId {
  a: Int @default(value: 10) @unique
  b: Int! @default(value: 10)
  b2: B!
  c: String! @unique
  createdAt: DateTime!
  d: String @default(value: \\"Hello\\")
  id: ID! @unique
  updatedAt: DateTime!
}

type B {
  a: [A]
  a2: AWithId
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
}"
`;

exports[`Introspects defaultValue/mysql correctly: defaultValue - v1.1 datamodel 1`] = `
"type A {
  a: Int @default(value: 10) @unique
  b: Int! @default(value: 10)
  c: String! @unique
  createdAt: DateTime! @createdAt
  d: String @default(value: \\"Hello\\")
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type AWithId {
  a: Int @default(value: 10) @unique
  b: Int! @default(value: 10)
  b2: B! @relation(link: TABLE)
  c: String! @unique
  createdAt: DateTime! @createdAt
  d: String @default(value: \\"Hello\\")
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type B {
  a: [A]
  a2: AWithId
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects embedded/mysql correctly: embedded - legacy datamodel 1`] = `
"type Child {
  c: String @unique
  createdAt: DateTime!
  friendsOpt: [Friend]
  id: ID! @unique
  jointOpt: Joint!
  updatedAt: DateTime!
}

type Friend {
  createdAt: DateTime!
  f: String @unique
  id: ID! @unique
  test: String
  updatedAt: DateTime!
}

type Joint {
  createdAt: DateTime!
  id: ID! @unique
  j: String
  updatedAt: DateTime!
}

type Parent {
  children: [Child]
  createdAt: DateTime!
  id: ID! @unique
  j: [Joint]
  p: String @unique
  updatedAt: DateTime!
}"
`;

exports[`Introspects embedded/mysql correctly: embedded - v1.1 datamodel 1`] = `
"type Child {
  c: String @unique
  createdAt: DateTime! @createdAt
  friendsOpt: [Friend]
  id: ID! @id
  jointOpt: Joint! @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
}

type Friend {
  createdAt: DateTime! @createdAt
  f: String @unique
  id: ID! @id
  test: String
  updatedAt: DateTime! @updatedAt
}

type Joint {
  createdAt: DateTime! @createdAt
  id: ID! @id
  j: String
  updatedAt: DateTime! @updatedAt
}

type Parent {
  children: [Child]
  createdAt: DateTime! @createdAt
  id: ID! @id
  j: [Joint]
  p: String @unique
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects emptyTypes/mysql correctly: emptyTypes - legacy datamodel 1`] = `
"type OnlyDate {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
}

type OnlyId {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
}

type OnlyIdAndARelation {
  createdAt: DateTime!
  id: ID! @unique
  ref: OnlyId!
  updatedAt: DateTime!
}

type OnlyIdAndARelation2 {
  createdAt: DateTime!
  id: ID! @unique
  ref: OnlyId
  updatedAt: DateTime!
}

type OnlyRelation {
  createdAt: DateTime!
  id: ID! @unique
  ref: [OnlyDate]
  updatedAt: DateTime!
}

type OnlyRelationA {
  createdAt: DateTime!
  id: ID! @unique
  ref: OnlyRelationA!
  updatedAt: DateTime!
}

type OnlyRelationB {
  createdAt: DateTime!
  id: ID! @unique
  ref: OnlyRelationB
  updatedAt: DateTime!
}"
`;

exports[`Introspects emptyTypes/mysql correctly: emptyTypes - v1.1 datamodel 1`] = `
"type OnlyDate {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type OnlyId {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type OnlyIdAndARelation {
  createdAt: DateTime! @createdAt
  id: ID! @id
  ref: OnlyId! @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
}

type OnlyIdAndARelation2 {
  createdAt: DateTime! @createdAt
  id: ID! @id
  ref: OnlyId @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
}

type OnlyRelation {
  createdAt: DateTime! @createdAt
  id: ID! @id
  ref: [OnlyDate]
  updatedAt: DateTime! @updatedAt
}

type OnlyRelationA {
  createdAt: DateTime! @createdAt
  id: ID! @id
  ref: OnlyRelationA! @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
}

type OnlyRelationB {
  createdAt: DateTime! @createdAt
  id: ID! @id
  ref: OnlyRelationB @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects enum/mysql correctly: enum - legacy datamodel 1`] = `
"type A {
  b: B!
  createdAt: DateTime!
  fieldA: UsedEnum
  fieldB: UsedEnum!
  fieldC: [UsedEnum]
  id: ID! @unique
  updatedAt: DateTime!
}

type AWithId {
  c: C
  createdAt: DateTime!
  fieldA: UsedEnum
  fieldB: UsedEnum!
  fieldC: [UsedEnum]
  id: ID! @unique
  updatedAt: DateTime!
}

type B {
  a: [A]
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
}

type C {
  a: AWithId!
  createdAt: DateTime!
  field: [Int]
  id: ID! @unique
  updatedAt: DateTime!
}

type D {
  a: AWithId!
  createdAt: DateTime!
  field: [DateTime]
  id: ID! @unique
  updatedAt: DateTime!
}

type E {
  a: [A]
  createdAt: DateTime!
  field: Json
  id: ID! @unique
  updatedAt: DateTime!
}

enum UnusedEnum {
  X
  Y
  Z
}

enum UsedEnum {
  A
  B
  C
  D
}"
`;

exports[`Introspects enum/mysql correctly: enum - v1.1 datamodel 1`] = `
"type A {
  b: B! @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  fieldA: UsedEnum
  fieldB: UsedEnum!
  fieldC: [UsedEnum] @scalarList(strategy: RELATION)
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type AWithId {
  c: C @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  fieldA: UsedEnum
  fieldB: UsedEnum!
  fieldC: [UsedEnum] @scalarList(strategy: RELATION)
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type B {
  a: [A]
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type C {
  a: AWithId!
  createdAt: DateTime! @createdAt
  field: [Int] @scalarList(strategy: RELATION)
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type D {
  a: AWithId! @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  field: [DateTime] @scalarList(strategy: RELATION)
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type E {
  a: [A]
  createdAt: DateTime! @createdAt
  field: Json
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

enum UnusedEnum {
  X
  Y
  Z
}

enum UsedEnum {
  A
  B
  C
  D
}"
`;

exports[`Introspects financial/mysql correctly: financial - legacy datamodel 1`] = `
"type Campus {
  accounts: [FinancialAccount]
  createdAt: DateTime!
  description: String
  id: ID! @unique
  isActive: Boolean
  location: Location
  name: String!
  organization: Group
  phoneNumbers: [PhoneNumber]
  updatedAt: DateTime!
}

type FinancialAccount {
  campuses: [Campus]
  createdAt: DateTime!
  description: String!
  id: ID! @unique
  isActive: Boolean!
  key: String @unique
  name: String
  updatedAt: DateTime!
}

type FinancialPaymentDetail {
  accountNumberMasked: String!
  achType: ACH_TYPE
  billingLocation: Location
  createdAt: DateTime!
  creditCardType: CREDIT_CARD
  currencyType: CURRENCY_TYPE
  expirationDate: DateTime!
  id: ID! @unique
  nameOnCard: String
  updatedAt: DateTime!
}

type FinancialScheduledTransaction {
  account: FinancialAccount
  amount: Float!
  createdAt: DateTime!
  endDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  id: ID! @unique
  isActive: Boolean!
  payment: FinancialPaymentDetail
  person: Person
  startDate: DateTime
  transactions: [FinancialTransaction]
  updatedAt: DateTime!
}

type FinancialTransaction {
  account: FinancialAccount
  amount: Float!
  createdAt: DateTime!
  id: ID! @unique
  organization: Group!
  payment: FinancialPaymentDetail
  person: Person
  processedDate: DateTime
  scheduledTransaction: FinancialScheduledTransaction
  status: TRANSACTION_STATUS!
  transactionDate: DateTime
  updatedAt: DateTime!
}

type Group {
  createdAt: DateTime!
  description: String
  id: ID! @unique
  invites: [GroupInvite]
  isActive: Boolean!
  key: String @unique
  members: [GroupMember]
  name: String!
  organization: Group
  type: GroupType!
  updatedAt: DateTime!
}

type GroupInvite {
  createdAt: DateTime!
  email: String!
  group: Group!
  groupRole: GroupRole
  id: ID! @unique
  status: GROUP_INVITE_STATUS!
  updatedAt: DateTime!
}

type GroupMember {
  createdAt: DateTime!
  group: Group
  id: ID! @unique
  person: Person
  role: GroupRole
  updatedAt: DateTime!
}

type GroupRole {
  canEdit: Boolean!
  canView: Boolean!
  createdAt: DateTime!
  description: String!
  groupType: GroupType
  id: ID! @unique
  isLeader: Boolean
  name: String! @unique
  type: GROUP_ROLE_TYPE
  updatedAt: DateTime!
}

type GroupType {
  createdAt: DateTime!
  description: String
  groups: [Group]
  id: ID! @unique
  name: String! @unique
  roles: [GroupRole]
  updatedAt: DateTime!
}

type Location {
  city: String
  createdAt: DateTime!
  id: ID! @unique
  locationType: LOCATION_TYPE
  postalCode: String
  state: String
  street1: String
  street2: String
  updatedAt: DateTime!
}

type Person {
  createdAt: DateTime!
  email: String
  firstName: String
  id: ID! @unique
  lastName: String
  phoneNumbers: [PhoneNumber]
  scheduledTransactions: [FinancialScheduledTransaction]
  transactions: [FinancialTransaction]
  updatedAt: DateTime!
  user: User
}

type PhoneNumber {
  createdAt: DateTime!
  id: ID! @unique
  number: String!
  updatedAt: DateTime!
}

type User {
  createdAt: DateTime!
  id: ID! @unique
  person: Person!
  updatedAt: DateTime!
}

enum ACH_TYPE {
  SAVINGS
  CHECKING
}

enum CREDIT_CARD {
  VISA
  MASTERCARD
  AMEX
  DISCOVER
}

enum CURRENCY_TYPE {
  ACH
  CC
}

enum GROUP_INVITE_STATUS {
  PENDING
  JOINED
}

enum GROUP_ROLE_TYPE {
  ADMIN
  OWNER
  MEMBER
}

enum LOCATION_TYPE {
  HOME
  WORK
}

enum TRANSACTION_FREQUENCY {
  DAILY
  MONTHLY
  BIWEEKLY
  CUSTOM
}

enum TRANSACTION_STATUS {
  PENDING
  SUCCESS
  FAILED
}"
`;

exports[`Introspects financial/mysql correctly: financial - v1.1 datamodel 1`] = `
"type Campus {
  accounts: [FinancialAccount]
  createdAt: DateTime! @createdAt
  description: String
  id: ID! @id
  isActive: Boolean
  location: Location @relation(link: TABLE)
  name: String!
  organization: Group @relation(link: TABLE)
  phoneNumbers: [PhoneNumber]
  updatedAt: DateTime! @updatedAt
}

type FinancialAccount {
  campuses: [Campus]
  createdAt: DateTime! @createdAt
  description: String!
  id: ID! @id
  isActive: Boolean!
  key: String @unique
  name: String
  updatedAt: DateTime! @updatedAt
}

type FinancialPaymentDetail {
  accountNumberMasked: String!
  achType: ACH_TYPE
  billingLocation: Location @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  creditCardType: CREDIT_CARD
  currencyType: CURRENCY_TYPE
  expirationDate: DateTime!
  id: ID! @id
  nameOnCard: String
  updatedAt: DateTime! @updatedAt
}

type FinancialScheduledTransaction {
  account: FinancialAccount @relation(link: TABLE)
  amount: Float!
  createdAt: DateTime! @createdAt
  endDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  id: ID! @id
  isActive: Boolean!
  payment: FinancialPaymentDetail @relation(link: TABLE)
  person: Person @relation(link: TABLE)
  startDate: DateTime
  transactions: [FinancialTransaction]
  updatedAt: DateTime! @updatedAt
}

type FinancialTransaction {
  account: FinancialAccount @relation(link: TABLE)
  amount: Float!
  createdAt: DateTime! @createdAt
  id: ID! @id
  organization: Group! @relation(link: TABLE)
  payment: FinancialPaymentDetail @relation(link: TABLE)
  person: Person @relation(link: TABLE)
  processedDate: DateTime
  scheduledTransaction: FinancialScheduledTransaction @relation(link: TABLE)
  status: TRANSACTION_STATUS!
  transactionDate: DateTime
  updatedAt: DateTime! @updatedAt
}

type Group {
  createdAt: DateTime! @createdAt
  description: String
  id: ID! @id
  invites: [GroupInvite]
  isActive: Boolean!
  key: String @unique
  members: [GroupMember]
  name: String!
  organization: Group @relation(link: TABLE)
  type: GroupType! @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
}

type GroupInvite {
  createdAt: DateTime! @createdAt
  email: String!
  group: Group! @relation(link: TABLE)
  groupRole: GroupRole @relation(link: TABLE)
  id: ID! @id
  status: GROUP_INVITE_STATUS!
  updatedAt: DateTime! @updatedAt
}

type GroupMember {
  createdAt: DateTime! @createdAt
  group: Group @relation(link: TABLE)
  id: ID! @id
  person: Person @relation(link: TABLE)
  role: GroupRole @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
}

type GroupRole {
  canEdit: Boolean!
  canView: Boolean!
  createdAt: DateTime! @createdAt
  description: String!
  groupType: GroupType @relation(link: TABLE)
  id: ID! @id
  isLeader: Boolean
  name: String! @unique
  type: GROUP_ROLE_TYPE
  updatedAt: DateTime! @updatedAt
}

type GroupType {
  createdAt: DateTime! @createdAt
  description: String
  groups: [Group]
  id: ID! @id
  name: String! @unique
  roles: [GroupRole]
  updatedAt: DateTime! @updatedAt
}

type Location {
  city: String
  createdAt: DateTime! @createdAt
  id: ID! @id
  locationType: LOCATION_TYPE
  postalCode: String
  state: String
  street1: String
  street2: String
  updatedAt: DateTime! @updatedAt
}

type Person {
  createdAt: DateTime! @createdAt
  email: String
  firstName: String
  id: ID! @id
  lastName: String
  phoneNumbers: [PhoneNumber]
  scheduledTransactions: [FinancialScheduledTransaction]
  transactions: [FinancialTransaction]
  updatedAt: DateTime! @updatedAt
  user: User
}

type PhoneNumber {
  createdAt: DateTime! @createdAt
  id: ID! @id
  number: String!
  updatedAt: DateTime! @updatedAt
}

type User {
  createdAt: DateTime! @createdAt
  id: ID! @id
  person: Person! @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
}

enum ACH_TYPE {
  SAVINGS
  CHECKING
}

enum CREDIT_CARD {
  VISA
  MASTERCARD
  AMEX
  DISCOVER
}

enum CURRENCY_TYPE {
  ACH
  CC
}

enum GROUP_INVITE_STATUS {
  PENDING
  JOINED
}

enum GROUP_ROLE_TYPE {
  ADMIN
  OWNER
  MEMBER
}

enum LOCATION_TYPE {
  HOME
  WORK
}

enum TRANSACTION_FREQUENCY {
  DAILY
  MONTHLY
  BIWEEKLY
  CUSTOM
}

enum TRANSACTION_STATUS {
  PENDING
  SUCCESS
  FAILED
}"
`;

exports[`Introspects flavian/mysql correctly: flavian - legacy datamodel 1`] = `
"type Post {
  author: User!
  content: String
  createdAt: DateTime!
  id: ID! @unique
  published: Boolean! @default(value: false)
  title: String!
  updatedAt: DateTime!
}

type User {
  createdAt: DateTime!
  email: String! @unique
  id: ID! @unique
  name: String
  posts: [Post]
  updatedAt: DateTime!
}"
`;

exports[`Introspects flavian/mysql correctly: flavian - v1.1 datamodel 1`] = `
"type Post {
  author: User! @relation(link: TABLE)
  content: String
  createdAt: DateTime! @createdAt
  id: ID! @id
  published: Boolean! @default(value: false)
  title: String!
  updatedAt: DateTime! @updatedAt
}

type User {
  createdAt: DateTime! @createdAt
  email: String! @unique
  id: ID! @id
  name: String
  posts: [Post]
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects meshRelation/mysql correctly: meshRelation - legacy datamodel 1`] = `
"type A {
  a: A!
  b: [B]
  c: C
  createdAt: DateTime!
  e: [E]
  field: Int!
  id: ID! @unique
  updatedAt: DateTime!
}

type B {
  a: A!
  b: [B]
  c: C @relation(name: \\"BToC\\")
  c2: C @relation(name: \\"BToC2\\")
  createdAt: DateTime!
  field: [String]
  id: ID! @unique
  updatedAt: DateTime!
}

type C {
  a: A
  b: [B] @relation(name: \\"BToC\\")
  b2: B @relation(name: \\"BToC2\\")
  c: C!
  createdAt: DateTime!
  expirationDate: DateTime
  id: ID! @unique
  updatedAt: DateTime!
}

type D {
  a: A!
  b: B!
  c: C!
  createdAt: DateTime!
  d: [D]
  field: Json
  id: ID! @unique
  updatedAt: DateTime!
}

type E {
  a: A!
  createdAt: DateTime!
  field: Json
  id: ID! @unique
  updatedAt: DateTime!
}"
`;

exports[`Introspects meshRelation/mysql correctly: meshRelation - v1.1 datamodel 1`] = `
"type A {
  a: A! @relation(link: TABLE)
  b: [B]
  c: C @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  e: [E]
  field: Int!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type B {
  a: A! @relation(link: TABLE)
  b: [B]
  c: C @relation(link: TABLE, name: \\"BToC\\")
  c2: C @relation(link: TABLE, name: \\"BToC2\\")
  createdAt: DateTime! @createdAt
  field: [String] @scalarList(strategy: RELATION)
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type C {
  a: A
  b: [B] @relation(name: \\"BToC\\")
  b2: B @relation(name: \\"BToC2\\")
  c: C! @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  expirationDate: DateTime
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type D {
  a: A! @relation(link: TABLE)
  b: B! @relation(link: TABLE)
  c: C! @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  d: [D]
  field: Json
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type E {
  a: A! @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  field: Json
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects oneSidedConnection/mysql correctly: oneSidedConnection - legacy datamodel 1`] = `
"type A {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: TypeWithId!
  y: TypeWithoutId!
}

type B {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: TypeWithId
  y: TypeWithoutId
}

type C {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: [TypeWithId]
  y: [TypeWithoutId]
}

type D {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: TypeWithId!
  y: TypeWithoutId!
}

type E {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: TypeWithId
  y: TypeWithoutId
}

type F {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: [TypeWithId]
  y: [TypeWithoutId]
}

type TypeWithId {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
}

type TypeWithoutId {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
}"
`;

exports[`Introspects oneSidedConnection/mysql correctly: oneSidedConnection - v1.1 datamodel 1`] = `
"type A {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: TypeWithId! @relation(link: TABLE)
  y: TypeWithoutId! @relation(link: TABLE)
}

type B {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: TypeWithId @relation(link: TABLE)
  y: TypeWithoutId @relation(link: TABLE)
}

type C {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [TypeWithId]
  y: [TypeWithoutId]
}

type D {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: TypeWithId! @relation(link: TABLE)
  y: TypeWithoutId! @relation(link: TABLE)
}

type E {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: TypeWithId @relation(link: TABLE)
  y: TypeWithoutId @relation(link: TABLE)
}

type F {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [TypeWithId]
  y: [TypeWithoutId]
}

type TypeWithId {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type TypeWithoutId {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects prisma-3143/mysql correctly: prisma-3143 - legacy datamodel 1`] = `
"type Story {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
}

type UserSpace {
  createdAt: DateTime!
  id: ID! @unique
  stories: [Story] @relation(name: \\"StoriesByUserSpace\\")
  updatedAt: DateTime!
}"
`;

exports[`Introspects prisma-3143/mysql correctly: prisma-3143 - v1.1 datamodel 1`] = `
"type Story {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type UserSpace {
  createdAt: DateTime! @createdAt
  id: ID! @id
  stories: [Story] @relation(name: \\"StoriesByUserSpace\\")
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects relationNames/mysql correctly: relationNames - legacy datamodel 1`] = `
"type A {
  createdAt: DateTime!
  id: ID! @unique
  toB: B! @relation(name: \\"RaToB\\")
  toB2: B! @relation(name: \\"RaToB2\\")
  toC: C
  updatedAt: DateTime!
}

type B {
  createdAt: DateTime!
  id: ID! @unique
  toA: A! @relation(name: \\"RaToB\\")
  toA2: A! @relation(name: \\"RaToB2\\")
  toC: C!
  updatedAt: DateTime!
}

type C {
  createdAt: DateTime!
  id: ID! @unique
  toA: [A]
  toB: [B]
  updatedAt: DateTime!
}"
`;

exports[`Introspects relationNames/mysql correctly: relationNames - v1.1 datamodel 1`] = `
"type A {
  createdAt: DateTime! @createdAt
  id: ID! @id
  toB: B! @relation(link: TABLE, name: \\"RaToB\\")
  toB2: B! @relation(link: TABLE, name: \\"RaToB2\\")
  toC: C @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
}

type B {
  createdAt: DateTime! @createdAt
  id: ID! @id
  toA: A! @relation(name: \\"RaToB\\")
  toA2: A! @relation(name: \\"RaToB2\\")
  toC: C! @relation(link: TABLE)
  updatedAt: DateTime! @updatedAt
}

type C {
  createdAt: DateTime! @createdAt
  id: ID! @id
  toA: [A]
  toB: [B]
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects relations/mysql correctly: relations - legacy datamodel 1`] = `
"type BillingInfo {
  account: String!
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  user: User!
}

type BillingInfoWithoutConnection {
  account: String!
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
}

type OptionalDetails {
  createdAt: DateTime!
  id: ID! @unique
  text: String!
  updatedAt: DateTime!
  user: User!
}

type OptionalDetailsWithoutConnection {
  createdAt: DateTime!
  id: ID! @unique
  text: String!
  updatedAt: DateTime!
}

type Post {
  count: Int!
  createdAt: DateTime!
  id: ID! @unique
  likes: [User] @relation(name: \\"LikesByUser\\")
  text: String!
  updatedAt: DateTime!
  user: User! @relation(name: \\"PostsByUser\\")
}

type PostWithoutConnection {
  count: Int!
  createdAt: DateTime!
  id: ID! @unique
  text: String!
  updatedAt: DateTime!
}

type User {
  billingInfo: BillingInfo!
  billingInfoWithoutConnection: BillingInfoWithoutConnection!
  createdAt: DateTime!
  id: ID! @unique
  likes: [Post] @relation(name: \\"LikesByUser\\")
  name: String!
  optionalDetails: OptionalDetails
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnection
  posts: [Post] @relation(name: \\"PostsByUser\\")
  postsWithoutConnection: [PostWithoutConnection]
  updatedAt: DateTime!
}"
`;

exports[`Introspects relations/mysql correctly: relations - v1.1 datamodel 1`] = `
"type BillingInfo {
  account: String!
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  user: User!
}

type BillingInfoWithoutConnection {
  account: String!
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type OptionalDetails {
  createdAt: DateTime! @createdAt
  id: ID! @id
  text: String!
  updatedAt: DateTime! @updatedAt
  user: User!
}

type OptionalDetailsWithoutConnection {
  createdAt: DateTime! @createdAt
  id: ID! @id
  text: String!
  updatedAt: DateTime! @updatedAt
}

type Post {
  count: Int!
  createdAt: DateTime! @createdAt
  id: ID! @id
  likes: [User] @relation(name: \\"LikesByUser\\")
  text: String!
  updatedAt: DateTime! @updatedAt
  user: User! @relation(link: TABLE, name: \\"PostsByUser\\")
}

type PostWithoutConnection {
  count: Int!
  createdAt: DateTime! @createdAt
  id: ID! @id
  text: String!
  updatedAt: DateTime! @updatedAt
}

type User {
  billingInfo: BillingInfo! @relation(link: TABLE)
  billingInfoWithoutConnection: BillingInfoWithoutConnection! @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  id: ID! @id
  likes: [Post] @relation(name: \\"LikesByUser\\")
  name: String!
  optionalDetails: OptionalDetails @relation(link: TABLE)
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnection @relation(link: TABLE)
  posts: [Post] @relation(name: \\"PostsByUser\\")
  postsWithoutConnection: [PostWithoutConnection]
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects scalars/mysql correctly: scalars - legacy datamodel 1`] = `
"type LotsOfRequiredScalars {
  boolean: Boolean!
  createdAt: DateTime!
  dateTime: DateTime!
  float: Float!
  id: ID! @unique
  int: Int!
  json: Json!
  string: String!
  updatedAt: DateTime!
}

type LotsOfRequiredScalarsWithID {
  boolean: Boolean!
  createdAt: DateTime!
  dateTime: DateTime!
  float: Float!
  id: ID! @unique
  int: Int!
  json: Json!
  string: String!
  updatedAt: DateTime!
}

type LotsOfScalarLists {
  boolean: [Boolean]
  createdAt: DateTime!
  dateTime: [DateTime]
  float: [Float]
  id: ID! @unique
  int: [Int]
  json: [Json]
  string: [String]
  updatedAt: DateTime!
}

type LotsOfScalarListsWithID {
  boolean: [Boolean]
  createdAt: DateTime!
  dateTime: [DateTime]
  float: [Float]
  id: ID! @unique
  int: [Int]
  json: [Json]
  string: [String]
  updatedAt: DateTime!
}

type LotsOfScalars {
  boolean: Boolean
  createdAt: DateTime!
  dateTime: DateTime
  float: Float
  id: ID! @unique
  int: Int
  json: Json
  string: String
  updatedAt: DateTime!
}

type LotsOfScalarsWithID {
  boolean: Boolean
  createdAt: DateTime!
  dateTime: DateTime
  float: Float
  id: ID! @unique
  int: Int
  json: Json
  string: String
  updatedAt: DateTime!
}"
`;

exports[`Introspects scalars/mysql correctly: scalars - v1.1 datamodel 1`] = `
"type LotsOfRequiredScalars {
  boolean: Boolean!
  createdAt: DateTime! @createdAt
  dateTime: DateTime!
  float: Float!
  id: ID! @id
  int: Int!
  json: Json!
  string: String!
  updatedAt: DateTime! @updatedAt
}

type LotsOfRequiredScalarsWithID {
  boolean: Boolean!
  createdAt: DateTime! @createdAt
  dateTime: DateTime!
  float: Float!
  id: ID! @id
  int: Int!
  json: Json!
  string: String!
  updatedAt: DateTime! @updatedAt
}

type LotsOfScalarLists {
  boolean: [Boolean] @scalarList(strategy: RELATION)
  createdAt: DateTime! @createdAt
  dateTime: [DateTime] @scalarList(strategy: RELATION)
  float: [Float] @scalarList(strategy: RELATION)
  id: ID! @id
  int: [Int] @scalarList(strategy: RELATION)
  json: [Json] @scalarList(strategy: RELATION)
  string: [String] @scalarList(strategy: RELATION)
  updatedAt: DateTime! @updatedAt
}

type LotsOfScalarListsWithID {
  boolean: [Boolean] @scalarList(strategy: RELATION)
  createdAt: DateTime! @createdAt
  dateTime: [DateTime] @scalarList(strategy: RELATION)
  float: [Float] @scalarList(strategy: RELATION)
  id: ID! @id
  int: [Int] @scalarList(strategy: RELATION)
  json: [Json] @scalarList(strategy: RELATION)
  string: [String] @scalarList(strategy: RELATION)
  updatedAt: DateTime! @updatedAt
}

type LotsOfScalars {
  boolean: Boolean
  createdAt: DateTime! @createdAt
  dateTime: DateTime
  float: Float
  id: ID! @id
  int: Int
  json: Json
  string: String
  updatedAt: DateTime! @updatedAt
}

type LotsOfScalarsWithID {
  boolean: Boolean
  createdAt: DateTime! @createdAt
  dateTime: DateTime
  float: Float
  id: ID! @id
  int: Int
  json: Json
  string: String
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects selfReferencing/mysql correctly: selfReferencing - legacy datamodel 1`] = `
"type MultiSelfReferencingB {
  a: MultiSelfReferencingB @relation(name: \\"AToA2\\")
  b: MultiSelfReferencingB @relation(name: \\"AToA2\\")
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
}

type MultiSelfReferencingBWithId {
  a: MultiSelfReferencingBWithId @relation(name: \\"WithIdAToA2\\")
  b: MultiSelfReferencingBWithId @relation(name: \\"WithIdAToA2\\")
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
}

type MultiSelfReferencingC {
  a: [MultiSelfReferencingC] @relation(name: \\"AToA\\")
  b: [MultiSelfReferencingC] @relation(name: \\"AToA\\")
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
}

type MultiSelfReferencingCWithId {
  a: [MultiSelfReferencingCWithId] @relation(name: \\"WithIdAToA\\")
  b: [MultiSelfReferencingCWithId] @relation(name: \\"WithIdAToA\\")
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
}

type SelfReferencingA {
  a: SelfReferencingAWithId!
  createdAt: DateTime!
  field: Int!
  id: ID! @unique
  updatedAt: DateTime!
}

type SelfReferencingAWithId {
  a: SelfReferencingAWithId!
  createdAt: DateTime!
  field: Int!
  id: ID! @unique
  updatedAt: DateTime!
}

type SelfReferencingB {
  a: SelfReferencingB
  createdAt: DateTime!
  field: Int!
  id: ID! @unique
  updatedAt: DateTime!
}

type SelfReferencingBWithId {
  a: SelfReferencingBWithId
  createdAt: DateTime!
  field: Int!
  id: ID! @unique
  updatedAt: DateTime!
}

type SelfReferencingC {
  a: [SelfReferencingC]
  createdAt: DateTime!
  field: Int!
  id: ID! @unique
  updatedAt: DateTime!
}

type SelfReferencingCWithId {
  a: [SelfReferencingBWithId]
  createdAt: DateTime!
  field: Int!
  id: ID! @unique
  updatedAt: DateTime!
}"
`;

exports[`Introspects selfReferencing/mysql correctly: selfReferencing - v1.1 datamodel 1`] = `
"type MultiSelfReferencingB {
  a: MultiSelfReferencingB @relation(link: TABLE, name: \\"AToA2\\")
  b: MultiSelfReferencingB @relation(name: \\"AToA2\\")
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type MultiSelfReferencingBWithId {
  a: MultiSelfReferencingBWithId @relation(link: TABLE, name: \\"WithIdAToA2\\")
  b: MultiSelfReferencingBWithId @relation(name: \\"WithIdAToA2\\")
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type MultiSelfReferencingC {
  a: [MultiSelfReferencingC] @relation(name: \\"AToA\\")
  b: [MultiSelfReferencingC] @relation(name: \\"AToA\\")
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type MultiSelfReferencingCWithId {
  a: [MultiSelfReferencingCWithId] @relation(name: \\"WithIdAToA\\")
  b: [MultiSelfReferencingCWithId] @relation(name: \\"WithIdAToA\\")
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type SelfReferencingA {
  a: SelfReferencingAWithId! @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  field: Int!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type SelfReferencingAWithId {
  a: SelfReferencingAWithId! @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  field: Int!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type SelfReferencingB {
  a: SelfReferencingB @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  field: Int!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type SelfReferencingBWithId {
  a: SelfReferencingBWithId @relation(link: TABLE)
  createdAt: DateTime! @createdAt
  field: Int!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type SelfReferencingC {
  a: [SelfReferencingC]
  createdAt: DateTime! @createdAt
  field: Int!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type SelfReferencingCWithId {
  a: [SelfReferencingBWithId]
  createdAt: DateTime! @createdAt
  field: Int!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects simple/mysql correctly: simple - legacy datamodel 1`] = `
"type User {
  createdAt: DateTime!
  id: ID! @unique
  name: String!
  updatedAt: DateTime!
}"
`;

exports[`Introspects simple/mysql correctly: simple - v1.1 datamodel 1`] = `
"type User {
  createdAt: DateTime! @createdAt
  id: ID! @id
  name: String!
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects todo/mysql correctly: todo - legacy datamodel 1`] = `
"type Todo {
  createdAt: DateTime!
  done: Boolean!
  id: ID! @unique
  text: String!
  updatedAt: DateTime!
  user: User!
}

type User {
  createdAt: DateTime!
  id: ID! @unique
  name: String!
  updatedAt: DateTime!
}"
`;

exports[`Introspects todo/mysql correctly: todo - v1.1 datamodel 1`] = `
"type Todo {
  createdAt: DateTime! @createdAt
  done: Boolean!
  id: ID! @id
  text: String!
  updatedAt: DateTime! @updatedAt
  user: User! @relation(link: TABLE)
}

type User {
  createdAt: DateTime! @createdAt
  id: ID! @id
  name: String!
  updatedAt: DateTime! @updatedAt
}"
`;

exports[`Introspects twoSidedConnection/mysql correctly: twoSidedConnection - legacy datamodel 1`] = `
"type AWithA {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: AWithIdWithA!
  y: AWithoutIdWithA!
}

type AWithB {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: BWithIdWithA!
  y: BWithoutIdWithA!
}

type AWithC {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: CWithIdWithA!
  y: CWithoutIdWithA!
}

type AWithIdWithA {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: AWithA!
}

type AWithIdWithB {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: BWithA!
}

type AWithIdWithC {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: CWithA!
}

type AWithoutIdWithA {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: AWithA!
}

type AWithoutIdWithB {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: BWithA!
}

type AWithoutIdWithC {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: CWithA!
}

type BWithA {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: AWithIdWithB
  y: AWithoutIdWithB
}

type BWithB {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: BWithIdWithB
  y: BWithoutIdWithB
}

type BWithC {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: CWithIdWithB
  y: CWithoutIdWithB
}

type BWithIdWithA {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: AWithB
}

type BWithIdWithB {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: BWithB
}

type BWithIdWithC {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: CWithB
}

type BWithoutIdWithA {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: AWithB
}

type BWithoutIdWithB {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: BWithB
}

type BWithoutIdWithC {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: CWithB
}

type CWithA {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: [AWithIdWithC]
  y: [AWithoutIdWithC]
}

type CWithB {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: [BWithIdWithC]
  y: [BWithoutIdWithC]
}

type CWithC {
  createdAt: DateTime!
  id: ID! @unique
  updatedAt: DateTime!
  x: [CWithIdWithC]
  y: [CWithoutIdWithC]
}

type CWithIdWithA {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: [AWithC]
}

type CWithIdWithB {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: [BWithC]
}

type CWithIdWithC {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: [CWithC]
}

type CWithoutIdWithA {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: [AWithC]
}

type CWithoutIdWithB {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: [BWithC]
}

type CWithoutIdWithC {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
  x: [CWithC]
}"
`;

exports[`Introspects twoSidedConnection/mysql correctly: twoSidedConnection - v1.1 datamodel 1`] = `
"type AWithA {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: AWithIdWithA!
  y: AWithoutIdWithA!
}

type AWithB {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: BWithIdWithA!
  y: BWithoutIdWithA!
}

type AWithC {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: CWithIdWithA! @relation(link: TABLE)
  y: CWithoutIdWithA! @relation(link: TABLE)
}

type AWithIdWithA {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: AWithA! @relation(link: TABLE)
}

type AWithIdWithB {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: BWithA! @relation(link: TABLE)
}

type AWithIdWithC {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: CWithA! @relation(link: TABLE)
}

type AWithoutIdWithA {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: AWithA! @relation(link: TABLE)
}

type AWithoutIdWithB {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: BWithA! @relation(link: TABLE)
}

type AWithoutIdWithC {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: CWithA! @relation(link: TABLE)
}

type BWithA {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: AWithIdWithB
  y: AWithoutIdWithB
}

type BWithB {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: BWithIdWithB
  y: BWithoutIdWithB
}

type BWithC {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: CWithIdWithB @relation(link: TABLE)
  y: CWithoutIdWithB @relation(link: TABLE)
}

type BWithIdWithA {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: AWithB @relation(link: TABLE)
}

type BWithIdWithB {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: BWithB @relation(link: TABLE)
}

type BWithIdWithC {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: CWithB @relation(link: TABLE)
}

type BWithoutIdWithA {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: AWithB @relation(link: TABLE)
}

type BWithoutIdWithB {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: BWithB @relation(link: TABLE)
}

type BWithoutIdWithC {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: CWithB @relation(link: TABLE)
}

type CWithA {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [AWithIdWithC]
  y: [AWithoutIdWithC]
}

type CWithB {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [BWithIdWithC]
  y: [BWithoutIdWithC]
}

type CWithC {
  createdAt: DateTime! @createdAt
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [CWithIdWithC]
  y: [CWithoutIdWithC]
}

type CWithIdWithA {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [AWithC]
}

type CWithIdWithB {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [BWithC]
}

type CWithIdWithC {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [CWithC]
}

type CWithoutIdWithA {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [AWithC]
}

type CWithoutIdWithB {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [BWithC]
}

type CWithoutIdWithC {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
  x: [CWithC]
}"
`;

exports[`Introspects withAndWithoutId/mysql correctly: withAndWithoutId - legacy datamodel 1`] = `
"type TypeWithId {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
}

type TypeWithoutId {
  createdAt: DateTime!
  field: String!
  id: ID! @unique
  updatedAt: DateTime!
}"
`;

exports[`Introspects withAndWithoutId/mysql correctly: withAndWithoutId - v1.1 datamodel 1`] = `
"type TypeWithId {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}

type TypeWithoutId {
  createdAt: DateTime! @createdAt
  field: String!
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}"
`;
